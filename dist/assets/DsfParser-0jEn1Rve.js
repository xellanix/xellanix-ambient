import{j as h,F as d,p as o,q as n,c,m as l}from"./index-CYC54ARG.js";import{A as p}from"./AbstractID3Parser-DzoY7MUJ.js";import{I as u}from"./ID3v2Parser-Q5FBc2t9.js";const r={len:12,get:(t,e)=>({id:d.get(t,e),size:h.get(t,e+4)})},k={len:16,get:(t,e)=>({fileSize:o.get(t,e),metadataPointer:o.get(t,e+8)})},g={len:40,get:(t,e)=>({formatVersion:n.get(t,e),formatID:n.get(t,e+4),channelType:n.get(t,e+8),channelNum:n.get(t,e+12),samplingFrequency:n.get(t,e+16),bitsPerSample:n.get(t,e+20),sampleCount:o.get(t,e+24),blockSizePerChannel:n.get(t,e+32)})},i=c("music-metadata:parser:DSF");class z extends l("DSD"){}class P extends p{async postId3v2Parse(){const e=this.tokenizer.position,s=await this.tokenizer.readToken(r);if(s.id!=="DSD ")throw new z("Invalid chunk signature");this.metadata.setFormat("container","DSF"),this.metadata.setFormat("lossless",!0);const a=await this.tokenizer.readToken(k);if(a.metadataPointer===BigInt(0))i("No ID3v2 tag present");else return i(`expect ID3v2 at offset=${a.metadataPointer}`),await this.parseChunks(a.fileSize-s.size),await this.tokenizer.ignore(Number(a.metadataPointer)-this.tokenizer.position-e),new u().parse(this.metadata,this.tokenizer,this.options)}async parseChunks(e){for(;e>=r.len;){const s=await this.tokenizer.readToken(r);switch(i(`Parsing chunk name=${s.id} size=${s.size}`),s.id){case"fmt ":{const a=await this.tokenizer.readToken(g);this.metadata.setFormat("numberOfChannels",a.channelNum),this.metadata.setFormat("sampleRate",a.samplingFrequency),this.metadata.setFormat("bitsPerSample",a.bitsPerSample),this.metadata.setFormat("numberOfSamples",a.sampleCount),this.metadata.setFormat("duration",Number(a.sampleCount)/a.samplingFrequency);const m=a.bitsPerSample*a.samplingFrequency*a.channelNum;this.metadata.setFormat("bitrate",m);return}default:this.tokenizer.ignore(Number(s.size)-r.len);break}e-=s.size}}}export{z as DsdContentParseError,P as DsfParser};
