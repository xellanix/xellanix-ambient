import{F as g,c as k,d,m as C,r as n,g as o,l as T,a as c}from"./index-BUEvymud.js";import{V as I,a as E,b as S}from"./VorbisParser-B5QC2GOB.js";import{A}from"./AbstractID3Parser-BKnKYnS8.js";import"./ID3v2Parser-DCD_H1Fg.js";const P=k("music-metadata:parser:FLAC");class h extends C("FLAC"){}const s={STREAMINFO:0,PADDING:1,APPLICATION:2,SEEKTABLE:3,VORBIS_COMMENT:4,CUESHEET:5,PICTURE:6};class y extends A{constructor(){super(...arguments),this.vorbisParser=new I(this.metadata,this.options),this.padding=0}async postId3v2Parse(){if((await this.tokenizer.readToken(g)).toString()!=="fLaC")throw new h("Invalid FLAC preamble");let a;do a=await this.tokenizer.readToken(u),await this.parseDataBlock(a);while(!a.lastBlock);if(this.tokenizer.fileInfo.size&&this.metadata.format.duration){const i=this.tokenizer.fileInfo.size-this.tokenizer.position;this.metadata.setFormat("bitrate",8*i/this.metadata.format.duration)}}async parseDataBlock(t){switch(P(`blockHeader type=${t.type}, length=${t.length}`),t.type){case s.STREAMINFO:return this.parseBlockStreamInfo(t.length);case s.PADDING:this.padding+=t.length;break;case s.APPLICATION:break;case s.SEEKTABLE:break;case s.VORBIS_COMMENT:return this.parseComment(t.length);case s.CUESHEET:break;case s.PICTURE:await this.parsePicture(t.length);return;default:this.metadata.addWarning(`Unknown block type: ${t.type}`)}return this.tokenizer.ignore(t.length).then()}async parseBlockStreamInfo(t){if(t!==p.len)throw new h("Unexpected block-stream-info length");const a=await this.tokenizer.readToken(p);this.metadata.setFormat("container","FLAC"),this.metadata.setFormat("codec","FLAC"),this.metadata.setFormat("lossless",!0),this.metadata.setFormat("numberOfChannels",a.channels),this.metadata.setFormat("bitsPerSample",a.bitsPerSample),this.metadata.setFormat("sampleRate",a.sampleRate),a.totalSamples>0&&this.metadata.setFormat("duration",a.totalSamples/a.sampleRate)}async parseComment(t){const a=await this.tokenizer.readToken(new d(t)),i=new E(a,0);i.readStringUtf8();const m=i.readInt32(),l=new Array(m);for(let r=0;r<m;r++)l[r]=i.parseUserComment();await Promise.all(l.map(r=>this.vorbisParser.addTag(r.key,r.value)))}async parsePicture(t){if(this.options.skipCovers)return this.tokenizer.ignore(t);const a=await this.tokenizer.readToken(new S(t));this.vorbisParser.addTag("METADATA_BLOCK_PICTURE",a)}}const u={len:4,get:(e,t)=>({lastBlock:T(e,t,7),type:o(e,t,1,7),length:n.get(e,t+1)})},p={len:34,get:(e,t)=>({minimumBlockSize:c.get(e,t),maximumBlockSize:c.get(e,t+2)/1e3,minimumFrameSize:n.get(e,t+4),maximumFrameSize:n.get(e,t+7),sampleRate:n.get(e,t+10)>>4,channels:o(e,t+12,4,3)+1,bitsPerSample:o(e,t+12,7,5)+1,totalSamples:o(e,t+13,4,36),fileMD5:new d(16).get(e,t+18)})};export{y as FlacParser};
